# Ports
PIN  pFromExternal
PIN  pFromInternal
POUT pToExternal
POUT pToInternal

# Resources Allocation
HASH five_tuple {IPV4.SRC, IPV4.DST, L4.SPORT, L4.DPORT, IPV4.PROTO}
HASH five_tuple_inverse {IPV4.DST, IPV4.SRC, L4.DPORT, L4.SPORT, IPV4.PROTO}

# State
REG tracker
VAR highwater
VAR ackNo
VAR random
VAR tmp
VAR payload_len
VAR ihl

# Stage 1: Pack from external (modify ACK)
HANDLER pack_from_external
  KEY PKT.PORT == pFromExternal
  KEY IPV4.PROTO == 6  # TCP
  KEY TCP.FLAGS == 16 # ACK FLAG ON
  DEFAULT FWD pToInternal
  begin:
    .rand 4, $random
    .mget tracker[five_tuple], $highwater
    .hcopy TCP.ACKNO, $ackNo
    .br.cond $highwater != $ackNo, L_UPDATE_ACK
  
  L_UPDATE_ACK:
    .sub $ackNo, $random, $ackNo
    .copy $ackNo, TCP.ACKNO
END

# Stage 2: Pack from internal (update highwater)
HANDLER pack_from_internal
  KEY PKT.PORT == pFromInternal
  KEY IPV4.PROTO == 6  # TCP
  DEFAULT FWD pToExternal
  begin:
    # Compute payload length = totalLen + seqNo - header offsets
    .hcopy IPV4.LEN, $payload_len
    .hcopy IPV4.IHL, $ihl
    .mul $ihl, 4, $ihl
    .hcopy TCP.DATAOFFSET, $tmp
    .mul $tmp, 4, $tmp
    .sum $ihl, $tmp, $tmp #options: .arit.sum $ihl, $tmp, $tmp | .arit $ihl + $tmp, $tmp
    .sub $payload_len, $tmp, $payload_len

    .br.cond $payload_len > 0, L_UPDATE_TRACKER

    L_UPDATE_TRACKER:
      .mset tracker[five_tuple_inverse], $payload_len
END
