from lib.tofino.runtime import *
from lib.tofino.types import *
from lib.tofino.constants import *
from lib.utils.utils import *
from lib.engine.engine_controller import *


class SystemApp(EngineController):

    def __init__(self, bfrt_runtime:bfrt_runtime):
        super().__init__(bfrt_runtime)
        self.program_name = "NetWarden Partial Ack"

    """

        In|S

        1 | f1 i4           isAccepted = acceptedConnections[index]
        1 | f1 i1           IF isAccepted == FALSE:
        1 | f1 i6               DROP

        0 random = RANDOM 4b

        highwater = p.ipv4.total_len
        highwater = highwater + p.tcp.seqNo


        highwater = p.ipv4.totalLen + p.tcp.seqNo
            fetch ipv4 total len -> save it into var 1
            fetch tcpSeqNo -> add it to var 1 -> save it

            speculative_fetch_between_vars
            ackNo = p.tcp.ackNo
        IF (highwater != ackNo):
            p.tcp.ackNo = p.tcp.ackNo - random #var->header

        ___________________________

        This is the same as:
        IF (highwater == ackNo):
            NOP
        ELSE:
            p.tcp.ackNo = p.tcp.ackNo - random #var->header


    """


    # Elements that need to be gathered from the manifest, need to appear as argument of the install method; otherwise they have been generated by the compiler
    def install(self, pFromExternal, pToExternal, pFromInternal, pToInternal, target_hw, program_id):
        # self._init_configs_()


        ########################################
        #######       PORTS CONFIG       #######
        ########################################
 
        if (target_hw):
            pFromExternal =  self.port_mechanism.port_hdl.get_dev_port(pFromExternal, 0)
            pToExternal =  self.port_mechanism.port_hdl.get_dev_port(pToExternal, 0)
            pFromInternal = self.port_mechanism.port_hdl.get_dev_port(pFromInternal, 0)
            pToInternal = self.port_mechanism.port_hdl.get_dev_port(pToInternal, 0)

        ########################################
        ####### CONSTANTS OF THE PROGRAM #######
        ########################################

        #Procedure pack_from_internal variables
        VAR_internal_tmp = 1
        VAR_internal_payload_len = 2
        
        #Procedure pack_from_external
        VAR_external_random=1    
        VAR_external_highwater=3
        VAR_external_ackNo=4


        ########################################
        #######     PKT IDS GENERATED    #######
        ########################################

        # Is generated one packet id per rule, so n + 2 ()
        pkt_id_disabled                             = 0
        pkt_id_all                                  = 1
        pkt_id_p_from_external_proto_tcp_ack_flag   = 2
        pkt_id_p_from_internal_proto_tcp            = 3
        
        ########################################
        #######     HASH UNITS CONFIG    #######
        ########################################
        # Hash1 === Hash3 (five_tuple_inverse) => first hash can be assigned by a var
        self.hash_mechanism[0].set_hash_mechanism([HASH_IPV4_DST_ADDR,HASH_IPV4_SRC_ADDR, HASH_L4_DPORT, HASH_L4_SPORT, HASH_IPV4_PROTO])
        self.hash_mechanism[2].set_hash_mechanism([HASH_IPV4_DST_ADDR,HASH_IPV4_SRC_ADDR, HASH_L4_DPORT, HASH_L4_SPORT, HASH_IPV4_PROTO])

        # Hash2 (five_tuple)
        self.hash_mechanism[1].set_hash_mechanism([HASH_IPV4_SRC_ADDR, HASH_IPV4_DST_ADDR, HASH_L4_SPORT, HASH_L4_DPORT, HASH_IPV4_PROTO])

        ########################################
        #######     PREFILTER RULES      #######
        ########################################


        pkt_id  = pkt_id_p_from_external_proto_tcp_ack_flag
        ni_f1   = 6
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromExternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], ipv4_proto=[PROTO_TCP, MASK_PROTO], tcp_flags=[MASK_TCP_ACK_FLAG, MASK_TCP_ACK_FLAG], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        self.pre_filter_mechanism.set_pkt_id_only(program_id=program_id, original_ig_port=[original_port, MASK_PORT],ipv4_proto=[PROTO_TCP, MASK_PROTO], tcp_flags=[MASK_TCP_ACK_FLAG, MASK_TCP_ACK_FLAG], pkt_id=pkt_id)


        pkt_id  = pkt_id_p_from_internal_proto_tcp
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromInternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], ipv4_proto=[PROTO_TCP, MASK_PROTO], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        self.pre_filter_mechanism.set_pkt_id_only(program_id=program_id, original_ig_port=[original_port, MASK_PORT], ipv4_proto=[PROTO_TCP, MASK_PROTO], pkt_id=pkt_id)


        # ### Default Entry
        # pkt_id  = pkt_id_all
        # ni_f1   = 1
        # ni_f2   = INSTRUCTION_FINISH

        # ### set default
        # self.pre_filter_mechanism.set_default_entry(BaseAction("set_pkt_id", pkt_id, ni_f1, ni_f2))


        ########################################
        #######       GENERIC FWD        #######
        ########################################
        pkt_id  =  pkt_id_p_from_external_proto_tcp_ack_flag
        port    =  pToInternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)
        
        pkt_id  =  pkt_id_p_from_internal_proto_tcp
        port    =  pToExternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)


        ########################################
        #######     RANDOM MECHANISM     #######
        ########################################
        
        #only in the first pass
        self.random_mechanism.random_4b_v1(program_id=program_id, f1_next_instr=[INSTRUCTION_FINISH, MASK_FLOW], ingress_port=[pFromExternal, MASK_PORT])

        ########################################
        #######      PROGRAM RULES       #######
        ########################################

        ####### f1_i1 #######

        current_instr    = 1
        next_instruct    = 1
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        self.f1.i1_p1.fetch_ipv4_total_len(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])


        current_instr    = 1
        next_instruct    = 1
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        # for enabling header->var
        self.f1.i1_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_to_var=1)

        ####### write s3 #######

        current_instr    = 1
        next_instruct    = 1
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        #payload_len = p.ipv4.totalLen
        self.f1.i3_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_internal_payload_len, var_update=1)

        current_instr    = 1
        next_instruct    = 1
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        self.f1.i3_speculative.speculative_fetch_tcp_seq(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_to_var=1)

        ####### write s5 #######

        current_instr    = 1
        next_instruct    = 2
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        #payload_len = ipv4.totalLen + tcp.seqNo
        self.f1.i5_p2.sum_increment_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_internal_payload_len, var_update=1)

        # instr_id => next
        self.f1.i5_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        #Enable recirculation for flow_id = 2
        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])


        ####### 2nd Pass #######

        current_instr    = 2
        next_instruct    = 2
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        ####### f1_i1 #######

        self.f1.i1_p1.fetch_ipv4_ihl(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])

        # for enabling header->var
        self.f1.i1_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_to_var=1)

        ####### write s3 #######


        current_instr    = 2
        next_instruct    = 9
        pkt_id           = pkt_id_p_from_internal_proto_tcp


        self.f1.i3_p2.mul_4x_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_internal_tmp, var_update=1)

        self.f1.i3_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])


        ####### write s5 #######

        ####### 3rd Pass #######
        current_instr    = 9
        next_instruct    = 3
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        self.f1.i1_p1.fetch_tcp_data_offset(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])

        #changing next_instr
        self.f1.i1_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, enabled=DISABLED)
        self.f1.i1_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_to_var=1)


        ####### write s3 #######
        current_instr    = 3
        next_instruct    = 3
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        # tcp_data_offset * 4, result stored in var_md.val
        self.f1.i3_p2.mul_4x_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        current_instr    = 3
        next_instruct    = 3
        pkt_id           = pkt_id_p_from_internal_proto_tcp
        #tmp in var_md.tmp
        self.f1.i3_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)


        ####### write s5 #######
        current_instr    = 3
        next_instruct    = 10
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        #var_md.tmp + var_md.val
        self.f1.i5_p2.sum_increment_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_internal_tmp, var_update=1)

        #for updating instr id
        self.f1.i5_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])

        

        ####### 4th Pass #######

        current_instr    = 10
        next_instruct    = 4
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        self.f1.i1_p1.fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])

        self.f1.i1_p2.complement_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        self.f1.i1_speculative.speculative_fetch_v2(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        ####### write s3 #######

        current_instr    = 4
        next_instruct    = 4
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        self.f1.i3_p2.sum_increment_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_internal_payload_len, var_update=1)

        ####### write s5 #######
        self.wp_s5.conditional_mechanism_after_reg.process_conditional_after_reg_f1(program_id=program_id, ni=current_instr, pkt_id=pkt_id, cond_mode=COND_MODE_GREATER, cond_val=0)

        current_instr    = 4
        next_instruct    = 11
        pkt_id           = pkt_id_p_from_internal_proto_tcp


        self.f1.i5_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], enabled=DISABLED, instr_id=next_instruct, cm=[COND_MODE_GREATER, MASK_COND_MODE], cval=[MASK_COND_VAL_MOST_SIGNIFICANT_BIT, MASK_COND_VAL_MOST_SIGNIFICANT_BIT])

        self.f1.i5_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, cm=[COND_MODE_GREATER, MASK_COND_MODE], cval=[MASK_COND_VAL_MOST_SIGNIFICANT_BIT,MASK_COND_VAL_MOST_SIGNIFICANT_BIT])


        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])

        ####### 5th Pass #######

        current_instr    = 11
        next_instruct    = 5
        pkt_id           = pkt_id_p_from_internal_proto_tcp

        self.f1.i1_p1.fetch_v2(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])

        self.f1.i1_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, enabled=DISABLED)

        self.f1.i1_speculative.speculative_set_index_hash_1_w_var(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mode=REG_OP_MODE_PUT)

        ####### write s3 #######

        current_instr    = 5
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_internal_proto_tcp


        self.f1.i3_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        ####### write s5 #######
        


        ####### Pkts from External #######

        current_instr    = 6
        next_instruct    = 6
        pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        
        self.f1.i1_p1.fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])

        current_instr    = 6
        next_instruct    = 6
        pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        
        #var 1 has random
        self.f1.i1_p2.complement_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_update=1, var_id=VAR_external_random)

        current_instr    = 6
        next_instruct    = 6
        pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        
        self.f1.i1_speculative.speculative_set_index_hash_2_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mode=REG_OP_MODE_GET)


        ####### write s3 #######
        current_instr    = 6
        next_instruct    = 6
        pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        
        self.f1.i3_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_external_highwater, var_update=1)

        self.f1.i3_speculative.speculative_fetch_tcp_ack(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_to_var=1)

        ####### write s5 #######
        current_instr    = 6
        next_instruct    = 7
        pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        

        self.f1.i5_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_update=1, var_id=VAR_external_ackNo)

        self.f1.i5_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])

        # ####### write s7 #######
        # current_instr    = 6
        # next_instruct    = 7
        # pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        
        # self.f1.i7_speculative.speculative_conditional_between_vars(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, cond_mode_2=COND_MODE_NOT_EQUALS)

        # self.pos_filter_mechansim.pos_filter_recirc_same_pipe(f1_next_instr=[next_instruct, MASK_FLOW])

        ####### 2nd Pass #######

        current_instr    = 7
        next_instruct    = 7
        pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        
        self.f1.i1_p1.conditional_between_vars(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], cond_mode_2=COND_MODE_NOT_EQUALS)

        self.f1.i1_speculative.speculative_fetch_tcp_ack(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        ####### write s3 ####### 

        self.f1.i3_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        self.f1.i3_speculative.speculative_fetch_v1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_to_header=1)

        ####### write s5 ####### 

        current_instr    = 7
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_external_proto_tcp_ack_flag
        

        self.f1.i5_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], cm_2=[COND_MODE_NOT_EQUALS, MASK_COND_MODE], cval_2=[MASK_COND_VAL, MASK_COND_VAL], enabled=DISABLED, instr_id=next_instruct)

        self.f1.i5_p2.sum_increment_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_update=1, header_id=HEADER_TCP_ACK_NO)

        # program_id = 1
        # program_name = "NetWardenPartialAck"
        # program = Program(program_id, program_name)
        self.write_phase_mechanism.set_write_phases(program_id=program_id, write_s3=1, write_s5=1, write_s10=1)
        # program.ports=set([pFromExternal, pToExternal, pFromInternal, pToInternal])
        # self.program_id_mechanism.add_program(program)


        # self._final_configs_()
        # self.program_enabler_mechanism.enable_program()
        # self.program_id_mechanism.set_program(1)
        return self

        # ####### Write Phase Configuration #######
        # self.write_phase_mechanism.set_write_phases(write_s3=1, write_s5=1, write_s10=1)

        # self._final_configs_()
        # self.program_enabler_mechanism.enable_program()
        