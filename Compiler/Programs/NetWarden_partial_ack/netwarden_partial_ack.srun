# Ports
pin  pFromExternal
pin  pFromInternal
pout pToExternal
pout pToInternal

# Resources Allocation
hash five_tuple {IPV4.SRC, IPV4.DST, L4.SPORT, L4.DPORT, IPV4.PROTO}
hash five_tuple_inverse {IPV4.DST, IPV4.SRC, L4.DPORT, L4.SPORT, IPV4.PROTO}

# State
reg tracker
var highwater
var ackNo
var random
var tmp
var payload_len
var ihl

# Stage 1: Pack from external (modify ACK)
handler pack_from_external
  key PKT.PORT == pFromExternal
  key IPV4.PROTO == 6  # TCP
  key TCP.FLAGS == 16 # ACK FLAG ON
  default FWD pToInternal
  begin:
    .rand 4, $random
    .mget tracker[five_tuple], $highwater
    .hcopy TCP.ACKNO, $ackNo
    .br.cond $highwater != $ackNo, L_UPDATE_ACK
  
  L_UPDATE_ACK:
    .sub $ackNo, $random, $ackNo
    .copy $ackNo, TCP.ACKNO
end

# Stage 2: Pack from internal (update highwater)
handler pack_from_internal
  key PKT.PORT == pFromInternal
  key IPV4.PROTO == 6  # TCP
  default FWD pToExternal
  begin:
    # Compute payload length = totalLen + seqNo - header offsets
    .hcopy IPV4.LEN, $payload_len
    .hcopy IPV4.IHL, $ihl
    .mul $ihl, 4, $ihl
    .hcopy TCP.DATAOFFSET, $tmp
    .mul $tmp, 4, $tmp
    .sum $ihl, $tmp, $tmp #options: .arit.sum $ihl, $tmp, $tmp | .arit $ihl + $tmp, $tmp
    .sub $payload_len, $tmp, $payload_len

    .br.cond $payload_len > 0, L_UPDATE_TRACKER

    L_UPDATE_TRACKER:
      .mset tracker[five_tuple_inverse], $payload_len
end
