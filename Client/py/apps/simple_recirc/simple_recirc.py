from lib.tofino.runtime import *
from lib.tofino.types import *
from lib.tofino.constants import *
from lib.utils.utils import *
from lib.engine.engine_controller import *


class SystemApp(EngineController):

    def __init__(self, bfrt_runtime:bfrt_runtime):
        super().__init__(bfrt_runtime)
        self.program_name = "NetWarden Partial Ack"

    """

        In|S

        1 | f1 i4           isAccepted = acceptedConnections[index]
        1 | f1 i1           IF isAccepted == FALSE:
        1 | f1 i6               DROP

        0 random = RANDOM 4b

        highwater = p.ipv4.total_len
        highwater = highwater + p.tcp.seqNo


        highwater = p.ipv4.totalLen + p.tcp.seqNo
            fetch ipv4 total len -> save it into var 1
            fetch tcpSeqNo -> add it to var 1 -> save it

            speculative_fetch_between_vars
            ackNo = p.tcp.ackNo
        IF (highwater != ackNo):
            p.tcp.ackNo = p.tcp.ackNo - random #var->header

        ___________________________

        This is the same as:
        IF (highwater == ackNo):
            NOP
        ELSE:
            p.tcp.ackNo = p.tcp.ackNo - random #var->header


    """


    # Elements that need to be gathered from the manifest, need to appear as argument of the install method; otherwise they have been generated by the compiler
    def install(self, pFromExternal, pToExternal, pFromInternal, pToInternal, target_hw, program_id):
        # self._init_configs_()


        ########################################
        #######       PORTS CONFIG       #######
        ########################################
 
        if (target_hw):
            pFromExternal =  self.port_mechanism.port_hdl.get_dev_port(pFromExternal, 0)
            pToExternal =  self.port_mechanism.port_hdl.get_dev_port(pToExternal, 0)
            pFromInternal = self.port_mechanism.port_hdl.get_dev_port(pFromInternal, 0)
            pToInternal = self.port_mechanism.port_hdl.get_dev_port(pToInternal, 0)

        ########################################
        ####### CONSTANTS OF THE PROGRAM #######
        ########################################

        #Procedure pack_from_internal variables
        VAR_internal_tmp = 1
        VAR_internal_payload_len = 2
        
        #Procedure pack_from_external
        VAR_external_random=1    
        VAR_external_highwater=3
        VAR_external_ackNo=4


        ########################################
        #######     PKT IDS GENERATED    #######
        ########################################

        # Is generated one packet id per rule, so n + 2 ()
        pkt_id_disabled                             = 0
        pkt_id_all                                  = 1
        pkt_id_p_from_external                      = 2
        pkt_id_p_from_internal                      = 3
        
        ########################################
        #######     HASH UNITS CONFIG    #######
        ########################################
        # Hash1 === Hash3 (five_tuple_inverse) => first hash can be assigned by a var
        # self.hash_mechanism[0].set_hash_mechanism([HASH_IPV4_DST_ADDR,HASH_IPV4_SRC_ADDR, HASH_L4_DPORT, HASH_L4_SPORT, HASH_IPV4_PROTO])
        # self.hash_mechanism[2].set_hash_mechanism([HASH_IPV4_DST_ADDR,HASH_IPV4_SRC_ADDR, HASH_L4_DPORT, HASH_L4_SPORT, HASH_IPV4_PROTO])

        # # Hash2 (five_tuple)
        # self.hash_mechanism[1].set_hash_mechanism([HASH_IPV4_SRC_ADDR, HASH_IPV4_DST_ADDR, HASH_L4_SPORT, HASH_L4_DPORT, HASH_IPV4_PROTO])

        ########################################
        #######     PREFILTER RULES      #######
        ########################################


        pkt_id  = pkt_id_p_from_external
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromExternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        self.pre_filter_mechanism.set_pkt_id_only(program_id=program_id, original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id)


        pkt_id  = pkt_id_p_from_internal
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromInternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        self.pre_filter_mechanism.set_pkt_id_only(program_id=program_id, original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id)


        # ### Default Entry
        # pkt_id  = pkt_id_all
        # ni_f1   = 1
        # ni_f2   = INSTRUCTION_FINISH

        # ### set default
        # self.pre_filter_mechanism.set_default_entry(BaseAction("set_pkt_id", pkt_id, ni_f1, ni_f2))


        ########################################
        #######       GENERIC FWD        #######
        ########################################
        pkt_id  =  pkt_id_p_from_external
        port    =  pToInternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)
        
        pkt_id  =  pkt_id_p_from_internal
        port    =  pToExternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)


        ########################################
        #######      PROGRAM RULES       #######
        ########################################

        ####### f1_i1 #######

        current_instr    = 1
        next_instruct    = 2
        pkt_id           = pkt_id_p_from_internal

        self.f1.i1_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, DISABLED], instr_id=next_instruct, enabled=DISABLED)

        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])


        current_instr    = 2
        next_instruct    = DISABLED
        pkt_id           = pkt_id_p_from_internal

        self.f1.i1_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, DISABLED], instr_id=next_instruct, enabled=DISABLED)


        self.write_phase_mechanism.set_write_phases(program_id=program_id, write_s10=1)

        return self
