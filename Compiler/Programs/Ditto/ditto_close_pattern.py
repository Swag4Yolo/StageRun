from py.control_plane.lib.runtime.runtime import *
from py.control_plane.lib.utils.types import *
from py.control_plane.lib.runtime.pipeline import *
from py.control_plane.lib.utils.constants import *
from py.control_plane.lib.utils.utils import *
from py.control_plane.lib_tofino.Queue import *
from py.control_plane.lib_tofino.Port import *
from py.control_plane.lib_tofino.Pktgen import *


class SystemApp(BRIPipeline):

    def __init__(self, bfrt_runtime:bfrt_runtime, switch_info):
        super().__init__(bfrt_runtime, switch_info)
        # self.program_name = "NetHide"

    def ditto_tofino_w_cloning(self, pattern=[600, 1600], ports_prio=[188, 172], ports_chaff=[32, 8], ports_rr=[140], total_rate=100000000, max_burst = 10000):

        def debug_dev_port_info(self, dev_port, queue_id):
                pipe = dev_port >> 7
                target = self.runtime.target

                port_cfg = self.runtime.bfrt_info.table_get("tm.port.cfg")
                key  = port_cfg.make_key([gc.KeyTuple('dev_port', dev_port)]) 
                resp = port_cfg.entry_get(target, [key])
                data = next(resp)[0].to_dict()
                
                pg_id = data['pg_id']
                pg_queue = data['egress_qid_queues'][queue_id]

                print('DEV_PORT: {}  QueueID: {}  --> Pipe: {}  PG_ID: {} PG_QUEUE: {}'.format(
                    dev_port, queue_id, pipe, pg_id, pg_queue))
                


        # p1      = 188
        # p2      = 172
        # p_input = 156
        # p_rr    = 140
        # p_tgen  = 68

        # p_c1    = 32
        # p_c2    = 8

        # margin = 0.01 # 1% margin
        margin = 0 # 1% margin


        rates = calculate_packet_rates(pattern, total_rate)
        print("Rates", rates)

        #Disable Chaff Max Rate
        # for i in range(len(ports_chaff)):
        #     dev_port = ports_chaff[i]
        #     max_rate = rates[i]
        #     debug_dev_port_info(self, dev_port, 1)
        #     debug_dev_port_info(self, dev_port, 2)
        #     port = Port(self.runtime.bfrt_info, dev_port)
        #     print(f"max_rate {max_rate} for pattern {pattern[i]} port {dev_port}")
        #     port.set_max_rate(max_rate)
        #     port.set_max_burst_size(max_burst)
        #     port.enable_max_rate()

        for dev_port in ports_rr:
            # port = Port(bfrt_info, dev_port)
            # port.set_max_rate(max_rate)
            # port.enable_max_rate()
            debug_dev_port_info(self, dev_port, 1)
            debug_dev_port_info(self, dev_port, 2)
            RoundRobinQueue(self.runtime.bfrt_info, dev_port=dev_port, queue_id=0)
            RoundRobinQueue(self.runtime.bfrt_info, dev_port=dev_port, queue_id=1)

        for i in range(len(ports_prio)):
            if i+1 > len(pattern):
                break
            dev_port = ports_prio[i]
            max_rate = int(rates[i] * (1-margin))
            print(f"max_rate {max_rate} for pattern {pattern[i]} port {dev_port}")
            debug_dev_port_info(self, dev_port, 1)
            debug_dev_port_info(self, dev_port, 2)
            fake_queue = FakeTrafficQueue(self.runtime.bfrt_info, dev_port=dev_port, queue_id=0)
            RealTrafficQueue(self.runtime.bfrt_info, dev_port=dev_port, queue_id=1)
            # fake_queue.disable_dynamic_buffer()

            port = Port(self.runtime.bfrt_info, dev_port)
            port.set_max_rate(max_rate, 'Kbps')
            port.set_max_burst_size(max_burst)
            port.enable_max_rate()



    # Elements that need to be gathered from the manifest, need to appear as argument of the install method; otherwise they have been generated by the compiler
    def install(self, P_INPUT, P1_IN, P1_OUT, P2_IN, P2_OUT, PC1_IN, PC2_IN, PC1_OUT, PC2_OUT, P_RECIRC_IN, P_RECIRC_OUT, PRR_OUT, P_FROM_TF2, P_TO_SERVER, target_hw):
        self._init_configs_()

        
        ########################################
        #######       PORTS CONFIG       #######
        ########################################

        if (target_hw):
            P_INPUT     = self.runtime.get_dev_port(P_INPUT, 0)
            P1_IN       = self.runtime.get_dev_port(P1_IN, 0)
            P1_OUT      = self.runtime.get_dev_port(P1_OUT, 0)
            P2_IN       = self.runtime.get_dev_port(P2_IN, 0)
            P2_OUT      = self.runtime.get_dev_port(P2_OUT, 0)
            PC1_IN      = self.runtime.get_dev_port(PC1_IN, 0)
            PC2_IN      = self.runtime.get_dev_port(PC2_IN, 0)
            PC1_OUT     = self.runtime.get_dev_port(PC1_OUT, 0)
            PC2_OUT     = self.runtime.get_dev_port(PC2_OUT, 0)
            P_RECIRC_IN   = self.runtime.get_dev_port(P_RECIRC_IN, 0)
            P_RECIRC_OUT  = self.runtime.get_dev_port(P_RECIRC_OUT, 0)
            PRR_OUT      = self.runtime.get_dev_port(PRR_OUT, 0)
            P_FROM_TF2  = self.runtime.get_dev_port(P_FROM_TF2, 0)
            P_TO_SERVER = self.runtime.get_dev_port(P_TO_SERVER, 0)


        ########################################
        ####### CONSTANTS OF THE PROGRAM #######
        ########################################

        PAT_1 = 1500
        PAT_2 = 1600
        PATTERN = [PAT_1, PAT_2]
        REAL_PATTERN = []
        for pat in PATTERN:
            # for ipv4_total_len conversion
            REAL_PATTERN.append(pat - 14)
        
        # print("REAL_PATTERN", REAL_PATTERN)

        self.ditto_tofino_w_cloning(PATTERN, [P2_IN, P1_IN], [PC1_IN, PC2_IN], [PRR_OUT])

        ########################################
        #######     PKT IDS GENERATED    #######
        ########################################

        # Is generated one packet id per rule, so n + 2 ()
        pkt_id_disabled       = 0
        pkt_id_all            = 1
        pkt_id_p1f            = 2
        pkt_id_p2f            = 3
        pkt_id_gen_200        = 4
        pkt_id_gen_500        = 5
        pkt_id_input          = 6
        pkt_id_gen_p1_cloning = 7
        pkt_id_gen_p2_cloning = 8
        pkt_id_to_tf2         = 9
        pkt_id_from_tf2       = 10
        
        
        ########################################
        #######     PREFILTER RULES      #######
        ########################################

        # Each body has a unique instruction number

        pkt_id  = pkt_id_gen_p1_cloning
        ni_f1   = 2
        ni_f2   = INSTRUCTION_FINISH
        original_port = PC1_IN

        self.pre_filter_mechanism.set_pkt_id(original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        pkt_id  = pkt_id_gen_p2_cloning
        ni_f1   = 2
        ni_f2   = INSTRUCTION_FINISH
        original_port = PC2_IN

        self.pre_filter_mechanism.set_pkt_id(original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        original_port = P1_IN
        pkt_id  = pkt_id_p1f
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH

        self.pre_filter_mechanism.set_pkt_id(original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        original_port = P2_IN
        pkt_id  = pkt_id_p2f
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH

        self.pre_filter_mechanism.set_pkt_id(original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        # This or the Default Entry could be both used in order to achieve the pattern
        original_port = P_INPUT
        pkt_id  = pkt_id_input
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH

        self.pre_filter_mechanism.set_pkt_id(original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        original_port = P_FROM_TF2
        pkt_id  = pkt_id_from_tf2
        ni_f1   = INSTRUCTION_FINISH
        ni_f2   = INSTRUCTION_FINISH

        self.pre_filter_mechanism.set_pkt_id(original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        # ### Default Entry
        # pkt_id  = pkt_id_all
        # ni_f1   = 1
        # ni_f2   = INSTRUCTION_FINISH

        # ### set default
        # self.pre_filter_mechanism.set_default_entry(BaseAction("set_pkt_id", pkt_id, ni_f1, ni_f2))



        ########################################
        #######       GENERIC FWD        #######
        ########################################
        pkt_id  =  pkt_id_p1f
        port    =  PRR_OUT
        qid     =  0
        self.generic_fwd.fwd_and_enqueue(pkt_id, port, qid)

        pkt_id  =  pkt_id_p2f
        port    =  PRR_OUT
        qid     =  1
        self.generic_fwd.fwd_and_enqueue(pkt_id, port, qid)

        pkt_id  =  pkt_id_gen_p1_cloning
        port    =  P1_OUT
        qid     =  0
        self.generic_fwd.fwd_and_enqueue(pkt_id, port, qid)

        pkt_id  =  pkt_id_gen_p2_cloning
        port    =  P2_OUT
        qid     =  0
        self.generic_fwd.fwd_and_enqueue(pkt_id, port, qid)

        pkt_id  =  pkt_id_from_tf2
        port    =  P_TO_SERVER
        self.generic_fwd.fwd(pkt_id, port)

        ########################################
        #######       MAIN PROGRAM       #######
        ########################################
        ####### f1_i1 #######

        current_instr    = 1
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_input

        self.f1.i1_p2.initialize_pad_ni(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mode=MODE_PADTTERN)

        current_instr    = 1
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_all
        self.f1.i1_p2.initialize_pad_ni(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mode=MODE_PADTTERN)

        
        #Come from PC1
        current_instr    = 2
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_gen_p1_cloning
        mirror_sid       = 100
        self.f1.i1_p2.initialize_activate_ni(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mirror_sid=mirror_sid)

        #Come from PC2
        current_instr    = 2
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_gen_p2_cloning
        mirror_sid       = 101
        self.f1.i1_p2.initialize_activate_ni(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mirror_sid=mirror_sid)

        ####### Mirror Configuration #######
        sid = 100
        # egress_port=P_TO_TF2
        egress_port=PC2_IN
        self.clone_mechanism.normal_cloning(sid=sid, ucast_egress_port=egress_port)

        sid = 101
        # egress_port=P_TO_TF2
        egress_port=PC1_IN
        self.clone_mechanism.normal_cloning(sid=sid, ucast_egress_port=egress_port)

        """        
        #### ORIGINAL
        bfrt.mirror.cfg.mod_with_normal(sid=100, ucast_egress_port=188, ucast_egress_port_valid=True, session_enable=True, direction='INGRESS', egress_port_queue=0)

        bfrt.mirror.cfg.mod_with_normal(sid=101, ucast_egress_port=172, ucast_egress_port_valid=True, session_enable=True, direction='INGRESS', egress_port_queue=0)

        #### CHANGED 172 <=> 8
        bfrt.mirror.cfg.mod_with_normal(sid=100, ucast_egress_port=188, ucast_egress_port_valid=True, session_enable=True, direction='INGRESS', egress_port_queue=0)

        bfrt.mirror.cfg.mod_with_normal(sid=101, ucast_egress_port=8, ucast_egress_port_valid=True, session_enable=True, direction='INGRESS', egress_port_queue=0)


        bfrt.mirror.cfg.mod_with_normal(sid=100, ucast_egress_port=188, ucast_egress_port_valid=True, session_enable=False, direction='INGRESS', egress_port_queue=0)

        bfrt.mirror.cfg.mod_with_normal(sid=101, ucast_egress_port=172, ucast_egress_port_valid=True, session_enable=False, direction='INGRESS', egress_port_queue=0)

        
        bfrt.tf1.tm.port.sched_cfg.mod(dev_port=188, max_rate_enable=False)
        bfrt.tf1.tm.port.sched_cfg.mod(dev_port=172, max_rate_enable=False)

        
        bfrt.tf1.tm.port.sched_cfg.mod(dev_port=188, max_rate_enable=True)
        bfrt.tf1.tm.port.sched_cfg.mod(dev_port=172, max_rate_enable=True)


        bfrt.tf1.tm.port.sched_shaping.mod(dev_port=8, max_rate=72727272, max_burst_size=10000, provisioning='MIN_ERROR')

        """
    
        ####### Pos Filter Mechanism #######

        ####### Chaff Traffic #######
        original_ig_port = [P_INPUT, MASK_PORT]
        ipv4_proto = [PROTO_GEN, MASK_POS_FILTER_IPV4_PROTO]
        ipv4_total_len = [REAL_PATTERN[0], MASK_IPV4_TLEN]
        port    =  PC2_IN
        self.pos_filter_mechansim.pos_filter_fwd(original_ig_port=original_ig_port, ipv4_proto=ipv4_proto, ipv4_total_len=ipv4_total_len, port=port)

        if (len(REAL_PATTERN) == 2):
            original_ig_port = [P_INPUT, MASK_PORT]
            ipv4_proto = [PROTO_GEN, MASK_POS_FILTER_IPV4_PROTO]
            ipv4_total_len = [REAL_PATTERN[1], MASK_IPV4_TLEN]
            port    =  PC1_IN
            self.pos_filter_mechansim.pos_filter_fwd(original_ig_port=original_ig_port, ipv4_proto=ipv4_proto, ipv4_total_len=ipv4_total_len, port=port)
            

        ####### Real Traffic #######
        original_ig_port = [P_INPUT, MASK_PORT]
        ipv4_total_len = [REAL_PATTERN[0], MASK_IPV4_TLEN]
        port = P1_OUT
        qid = 1
        self.pos_filter_mechansim.pos_filter_fwd_and_enqueue(original_ig_port=original_ig_port, ipv4_total_len=ipv4_total_len, port=port, qid=qid)

        if (len(REAL_PATTERN) == 2):
            original_ig_port = [P_INPUT, MASK_PORT]
            ipv4_total_len = [REAL_PATTERN[1], MASK_IPV4_TLEN]
            port = P2_OUT
            qid = 1
            self.pos_filter_mechansim.pos_filter_fwd_and_enqueue(original_ig_port=original_ig_port, ipv4_total_len=ipv4_total_len, port=port, qid=qid)

        ####### Recirculation #######
        original_ig_port = [P_RECIRC_IN, MASK_PORT]
        ipv4_total_len = [REAL_PATTERN[0], MASK_IPV4_TLEN]
        port = P1_OUT
        qid = 1
        self.pos_filter_mechansim.pos_filter_fwd_and_enqueue(original_ig_port=original_ig_port, ipv4_total_len=ipv4_total_len, port=port, qid=qid)

        if (len(REAL_PATTERN) == 2):
            original_ig_port = [P_RECIRC_IN, MASK_PORT]
            ipv4_total_len = [REAL_PATTERN[1], MASK_IPV4_TLEN]
            port = P2_OUT
            qid = 1
            self.pos_filter_mechansim.pos_filter_fwd_and_enqueue(original_ig_port=original_ig_port, ipv4_total_len=ipv4_total_len, port=port, qid=qid)

        original_ig_port = [P_INPUT, MASK_PORT]
        port = P_RECIRC_OUT
        self.pos_filter_mechansim.pos_filter_fwd(original_ig_port=original_ig_port, port=port)


        self.pattern_mechanism.add_size_pattern(REAL_PATTERN)

        program_id = 1
        program_name = "Ditto"
        program = Program(program_id, program_name)
        program.set_write_phases(write_s10=1) # need this to update mirror mechanism
        program.ports=set([P_INPUT, P1_IN, P1_OUT, P2_IN, P2_OUT, PC1_IN, PC2_IN, PC1_OUT, PC2_OUT, P_RECIRC_IN, P_RECIRC_OUT, PRR_OUT, P_FROM_TF2, P_TO_SERVER])
        self.program_id_mechanism.add_program(program)


        self._final_configs_()
        self.program_enabler_mechanism.enable_program()
        self.program_id_mechanism.set_program(1)
        return self

        # ####### Write Phase Configuration #######
        # self.write_phase_mechanism.set_write_phases(write_s10=1)
        # self.program_enabler_mechanism.enable_program()

        # self._final_configs_()
        # self.program_enabler_mechanism.enable_program()
        