// stagerun_grammar.lark

start: NEWLINE* statement (NEWLINE+ statement)* NEWLINE*

?statement: port_in_decl
          | port_out_decl
          | qset_decl
          | var_decl
          | reg_decl
          | hash_decl
          | handler
          | setup

// PORTS
// port_declr: "PORT" NAME
port_in_decl: "pin" NAME
port_out_decl: "pout" NAME NAME?

// QUEUES
//TODO: I have written rules for qset_decl (line 21) setup (lines 24, 25) and for setup options, such as loop_setup, and pattern_setup (lines 27, 28). I want you to modify the necessary files to implement this new instructions.
qset_decl: "queue" NAME NAME NAME INT

// Control Plane Setup
setup: "setup" setup_type 
setup_type: loop_setup
          | pattern_setup
loop_setup:    "loop" NAME NAME
pattern_setup: "pattern" NAME INT+


// Resources
var_decl: "var" NAME
reg_decl: "reg" NAME
hash_decl: "hash" NAME "{" (header_ref | INT) ("," (header_ref | INT))* "}"

handler: "handler" NAME NEWLINE+ clause_line* "end"


?clause_line: (key_clause | default_clause) NEWLINE+
            | body_clause NEWLINE*
            | pos_clause NEWLINE*

key_clause: "key" key_ref (comp_op | mask_op) value
default_clause: "default" default_instr

pos_clause: pos_key_clause NEWLINE pos_default_clause NEWLINE+
pos_key_clause: "poskey" key_ref (comp_op | mask_op) value
pos_default_clause: "posdefault" default_instr

body_clause: label_decl NEWLINE+ instr_line+ NEWLINE*
instr_line: instr NEWLINE+

?default_instr: default_fwd_instr
              | default_drop_instr
              | default_fwd_queue_instr

default_fwd_instr: "FWD" NAME
default_fwd_queue_instr: "FWD_AND_ENQUEUE" NAME SIGNED_INT
default_drop_instr: "DROP"
// default_rts_instr: "RTS"


      // Fwd Ops      
?instr: fwd_instr
      | fwd_queue_instr
      | drop_instr
      | rts_instr
      // Arith Instructions
      | sum_instr
      | sub_instr
      | mul_instr
      | inc_instr
      | hinc_instr
      | header_assign_instr
      | clone_instr
      | paddtern_instr
      | time_instr
      // Mem Ops
      | minc_instr
      | mget_instr
      | mset_instr
      // Convert ops
      | copy_header_to_var_instr
      | copy_hash_to_var_instr
      | copy_var_to_header_instr
      | activate_instr
      // | ingress_ts_instr
      // | airth_instr
      // | hairth_instr
      | random_instr
      | in_instr
      | out_instr
      | conditional_clause
      | jmp_instr


// Instructions List
fwd_instr: ".fwd" NAME
fwd_queue_instr: ".fwd.enq" NAME SIGNED_INT
drop_instr: ".drop"
rts_instr: ".rts"

// Header Arithmetic Operations
hinc_instr: ".hinc" header_ref "," SIGNED_INT "," header_ref
header_assign_instr: ".hassign" header_ref "," (SIGNED_INT | STRING)
clone_instr: ".clone" NAME
paddtern_instr: ".pad.pattern" INT+
activate_instr: ".activate" NAME
// ingress_ts_instr: ".igts" "->" var_ref
random_instr: ".rand" SIGNED_INT "," var_ref
time_instr: ".time" "," var_ref

// Arithmetic Operations
inc_instr: ".inc" var_ref "," SIGNED_INT "," var_ref
sum_instr: ".sum" var_ref "," var_ref "," var_ref
sub_instr: ".sub" var_ref "," var_ref "," var_ref
mul_instr: ".mul" var_ref "," SIGNED_INT "," var_ref

// Memory Instructions
minc_instr: ".minc" reg_ref "[" (hash_ref | header_ref) "]" "," (header_ref | SIGNED_INT) "," var_ref ("," NAME)?
mget_instr: ".mget" reg_ref "[" (hash_ref | header_ref) "]" "," var_ref ("," NAME)?
mset_instr: ".mset" reg_ref "[" (hash_ref | header_ref) "]" "," (header_ref | var_ref | SIGNED_INT) ("," NAME)?

// Convert Instrs
copy_header_to_var_instr: ".hcopy" header_ref "," var_ref
copy_hash_to_var_instr: ".hashcopy" hash_ref "," var_ref
copy_var_to_header_instr: ".copy" var_ref "," header_ref

// State Instrs
in_instr: ".in" var_ref
out_instr: ".out" var_ref

// Conditional Instrs
//TODO: delete
if_block: if_clause elif_clause* else_clause? "ENDIF"
if_clause: "IF" bool_expr ":" instr+
elif_clause: "ELIF" bool_expr ":" instr+
else_clause: "ELSE" ":" instr+

conditional_clause: ".br.cond" bool_expr "," label

// Label Instruction
jmp_instr: ".jmp" NAME

// =====================
// Expressões booleanas SEM headers
//   - var_ref: NAME simples (p.ex., proto, size)
//   - constantes: inteiros (suporta sinal)
//   - operadores: &&, ||, !, parêntesis, comparações
// =====================
?bool_expr: or_expr

?or_expr: and_expr
        | or_expr "||" and_expr

?and_expr: not_expr
         | and_expr "&&" not_expr

?not_expr: comparison
         | "!" not_expr
         | "(" bool_expr ")"

?comparison: arith_val comp_op arith_val
           | "(" comparison ")"

EQ: "=="
NE: "!="
LT: "<"
LE: "<="
GT: ">"
GE: ">="

comp_op: EQ | NE | LT | LE | GT | GE

MASK: "&"
mask_op: MASK

?arith_val: var_ref
          | SIGNED_INT
          | "(" arith_val ")"


// Arithmetic Ops
ARIT_OR: "|"
ARIT_AND: "&"
ARIT_SUM: "+"
ARIT_SUB: "-"
ARIT_MUL: "*"

arith_op: ARIT_OR | ARIT_AND | ARIT_SUM | ARIT_SUB | ARIT_MUL

// Atenção: var_ref é APENAS NAME (sem ponto); nada de headers aqui.



key_ref:  NAME "." NAME
header_ref: NAME "." NAME
var_ref: "$"NAME
reg_ref: NAME
hash_ref: NAME
value: NAME | STRING | SIGNED_INT

// Label
label_decl: NAME ":"
label: NAME

// IPV4_ADDR: /(?:(?:25[0-5]|2[0-4]\d|1?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|1?\d?\d)){3})/
NAME: /[A-Za-z_][A-Za-z0-9_]*/
STRING: /"[^"]*"/
LINE_COMMENT: /#[^\n]*/
BLOCK_COMMENT: /\/\*[\s\S]*?\*\//
%ignore LINE_COMMENT
%ignore BLOCK_COMMENT
%import common.INT
%import common.SIGNED_INT
%import common.NEWLINE
%import common.WS_INLINE
%ignore WS_INLINE
// %import common.WS
// %ignore WS
// %ignore /#[^\n]*/ // Language Comments
// %ignore /[\r\n]+/
