from lib.tofino.runtime import *
from lib.tofino.types import *
from lib.tofino.constants import *
from lib.utils.utils import *
from lib.engine.engine_controller import *


class SystemApp(EngineController):

    def __init__(self, bfrt_runtime:bfrt_runtime):
        super().__init__(bfrt_runtime)
        self.program_name = "Mew CrossFire Mitigation System"

    """

        In|S

        when (p.tcp.dport == SSH_SERVER_PORT) -> fwd(pToServer):


        1 | f1 i4           isAccepted = acceptedConnections[index]
        1 | f1 i1           IF isAccepted == FALSE:
        1 | f1 i6               DROP

        _______

        when (p.tcp.dport == K1_DPORT) -> fwd(pToServer):


        2 | f1 i1     knockStatus[index] = 1

        _______

        when (p.tcp.dport == K2_DPORT) -> fwd(pToServer):

        
        3 | f1 i1        status = knockStatus[index]
        3 | f1 i1        IF status == 1: 
        5 | f1 i1            knockStatus[index] = 2 
        3 | f1 i1        ELSE: 
        6 | f1 i1            knockStatus[index] = 0

        _______

        when (p.tcp.dport == K3_DPORT) -> fwd(pToServer):

        4 | f1 i1        status = knockStatus[index]
        4 | f1 i1        IF status == 2:
        7 | f1 i1            acceptedConnections[index] = TRUE 
        4 | f1 i1        ELSE:
        8 | f1 i1            knockStatus[index] = 0

    """


    # Elements that need to be gathered from the manifest, need to appear as argument of the install method; otherwise they have been generated by the compiler
    def install(self, pFromExternal, pToExternal, pFromInternal, pToInternal, target_hw, program_id):
        # self._init_configs_()


        ########################################
        #######       PORTS CONFIG       #######
        ########################################
 
        if (target_hw):
            pFromExternal =  self.port_mechanism.port_hdl.get_dev_port(pFromExternal, 0)
            pToExternal =  self.port_mechanism.port_hdl.get_dev_port(pToExternal, 0)
            pFromInternal = self.port_mechanism.port_hdl.get_dev_port(pFromInternal, 0)
            pToInternal = self.port_mechanism.port_hdl.get_dev_port(pToInternal, 0)

        ########################################
        ####### CONSTANTS OF THE PROGRAM #######
        ########################################
        VAR_isAccepted=1
        VAR_status=2

        CONST_SSH_DPORT = 22
        CONST_K1_DPORT  = 1234
        CONST_K2_DPORT  = 5678
        CONST_K3_DPORT  = 9012


        ########################################
        #######     PKT IDS GENERATED    #######
        ########################################

        # Is generated one packet id per rule, so n + 2 ()
        pkt_id_disabled                                 = 0
        pkt_id_all                                      = 1
        pkt_id_p_from_external_tcp_dport_ssh_server     = 2
        pkt_id_p_from_external_tcp_dport_k1             = 3
        pkt_id_p_from_external_tcp_dport_k2             = 4
        pkt_id_p_from_external_tcp_dport_k3             = 5
        pkt_id_p_from_internal                          = 6
        
        ########################################
        #######     HASH UNITS CONFIG    #######
        ########################################
        # Hash1 === Hash3
        self.hash_mechanism[0].set_hash_mechanism([HASH_IPV4_SRC_ADDR])
        self.hash_mechanism[2].set_hash_mechanism([HASH_IPV4_SRC_ADDR])

        # Hash2
        # self.hash_mechanism[1].set_hash_mechanism([HASH_IPV4_SRC_ADDR, HASH_IPV4_DST_ADDR, HASH_L4_SPORT, HASH_L4_DPORT, HASH_IPV4_PROTO])

        ########################################
        #######     PREFILTER RULES      #######
        ########################################


        pkt_id  = pkt_id_p_from_external_tcp_dport_ssh_server
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromExternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], tcp_dst_port=[CONST_SSH_DPORT, MASK_TCP_DPORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)
        

        pkt_id  = pkt_id_p_from_external_tcp_dport_k1
        ni_f1   = 2
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromExternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], tcp_dst_port=[CONST_K1_DPORT, MASK_TCP_DPORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)


        pkt_id  = pkt_id_p_from_external_tcp_dport_k2
        ni_f1   = 3
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromExternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], tcp_dst_port=[CONST_K2_DPORT, MASK_TCP_DPORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        #for recirculation
        self.pre_filter_mechanism.set_pkt_id_only(original_ig_port=[original_port, MASK_PORT], tcp_dst_port=[CONST_K2_DPORT, MASK_TCP_DPORT], pkt_id=pkt_id)


        pkt_id  = pkt_id_p_from_external_tcp_dport_k3
        ni_f1   = 4
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromExternal

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, ig_port=[original_port, MASK_PORT], tcp_dst_port=[CONST_K3_DPORT, MASK_TCP_DPORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        #for recirculation
        self.pre_filter_mechanism.set_pkt_id_only(program_id=program_id, original_ig_port=[original_port, MASK_PORT], tcp_dst_port=[CONST_K3_DPORT, MASK_TCP_DPORT], pkt_id=pkt_id)

        pkt_id  = pkt_id_p_from_internal
        ni_f1   = INSTRUCTION_FINISH
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromInternal

        self.pre_filter_mechanism.set_pkt_id(ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)



        # ### Default Entry
        # pkt_id  = pkt_id_all
        # ni_f1   = 1
        # ni_f2   = INSTRUCTION_FINISH

        # ### set default
        # self.pre_filter_mechanism.set_default_entry(BaseAction("set_pkt_id", pkt_id, ni_f1, ni_f2))


        ########################################
        #######       GENERIC FWD        #######
        ########################################
        pkt_id  =  pkt_id_p_from_external_tcp_dport_ssh_server
        port    =  pToInternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)
        
        pkt_id  =  pkt_id_p_from_external_tcp_dport_k1
        port    =  pToInternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)
        
        pkt_id  =  pkt_id_p_from_external_tcp_dport_k2
        port    =  pToInternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)
        
        pkt_id  =  pkt_id_p_from_external_tcp_dport_k3
        port    =  pToInternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)
        
        pkt_id  =  pkt_id_p_from_internal
        port    =  pToExternal
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)

        ########################################
        #######      PROGRAM RULES       #######
        ########################################

        # knockStatus         => f1 i1, i2
        # acceptedConnections => f1 i4

        ####### SSH_SERVER_PORT #######

        ####### f1_i1 #######

        current_instr    = 1
        next_instruct    = 1
        pkt_id           = pkt_id_p_from_external_tcp_dport_ssh_server

        self.f1.i3_speculative.speculative_set_index_hash_1_w_const_val(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mode=REG_OP_MODE_GET)

        self.f1.i4_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_isAccepted, var_update=1)

        ####### write s6 #######
        current_instr    = 1
        next_instruct    = 1
        pkt_id           = pkt_id_p_from_external_tcp_dport_ssh_server

        self.wp_s6.conditional_mechanism_after_reg.process_conditional_after_reg_f1(program_id=program_id, ni=current_instr, pkt_id=pkt_id, cond_mode=COND_MODE_EQUALS, cond_val=0)

        ####### f1_i6 #######

        current_instr    = 1
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_external_tcp_dport_ssh_server

        self.f1.i6_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, mark_to_drop=1, cm=[COND_MODE_EQUALS, MASK_COND_MODE], cval=[0, MASK_COND_VAL])



        ####### K1_DPORT #######

        ####### f1_i1 #######

        current_instr    = 2
        next_instruct    = INSTRUCTION_FINISH 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k1

        self.f1.i1_p1.set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_PUT, mem_const_val=1)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)


        ####### K2_DPORT #######

        ####### f1_i1 #######

        current_instr    = 3
        next_instruct    = 3 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k2

        self.f1.i1_p1.set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_GET)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_status, var_update=1)


        current_instr    = 5
        next_instruct    = INSTRUCTION_FINISH 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k2

        self.f1.i1_p1.set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_PUT, mem_const_val=2)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)


        current_instr    = 6
        next_instruct    = INSTRUCTION_FINISH 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k2

        self.f1.i1_p1.set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_PUT, mem_const_val=0)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)

        
        ####### stage s3 #######

        current_instr    = 3
        next_instruct    = 3 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k2

        self.wp_s3.conditional_mechanism_after_reg.process_conditional_after_reg_f1(program_id=program_id, ni=current_instr, pkt_id=pkt_id, cond_mode=COND_MODE_EQUALS, cond_val=1)


        ####### f1_i3 #######        

        #TODO: speculative should also be called to adjust speculative_instr; this will need to be in the compiler => speculative_nop

        current_instr    = 3
        next_instruct    = 5
        pkt_id           = pkt_id_p_from_external_tcp_dport_k2

        #fwd ni can be used to change the flow_id for instructions, since exec_instr is no longer available
        self.f1.i3_p2.fwd_ni(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], cm=[COND_MODE_EQUALS, MASK_COND_MODE], cval=[0, MASK_COND_VAL], instr_id=next_instruct, enabled=DISABLED)
        

        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])

        current_instr    = 3
        next_instruct    = 6
        pkt_id           = pkt_id_p_from_external_tcp_dport_k2

        #fwd ni can be used to change the flow_id for instructions, since exec_instr is no longer available
        self.f1.i3_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, enabled=DISABLED)
        
        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])


        ####### K3_DPORT #######

        ####### f1_i1 #######

        current_instr    = 4
        next_instruct    = 4 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k3

        self.f1.i1_p1.set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_GET)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=VAR_status, var_update=1)

        
        current_instr    = 8
        next_instruct    = INSTRUCTION_FINISH 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k3

        self.f1.i1_p1.set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_PUT, mem_const_val=0)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)


        ####### write s3 #######

        current_instr    = 4
        next_instruct    = 4 
        pkt_id           = pkt_id_p_from_external_tcp_dport_k3

        self.wp_s3.conditional_mechanism_after_reg.process_conditional_after_reg_f1(program_id=program_id, ni=current_instr, pkt_id=pkt_id, cond_mode=COND_MODE_EQUALS, cond_val=2)

        ####### f1_i3 #######

        current_instr    = 4
        next_instruct    = 7
        pkt_id           = pkt_id_p_from_external_tcp_dport_k3

        self.f1.i3_speculative.speculative_set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], cm=[COND_MODE_EQUALS, MASK_COND_MODE], cval=[0, MASK_COND_VAL], instr_id=next_instruct, mode=REG_OP_MODE_PUT, mem_const_val=1)

        #for updating next instr
        self.f1.i3_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], cm=[COND_MODE_EQUALS, MASK_COND_MODE], cval=[0, MASK_COND_VAL], instr_id=next_instruct, enabled=DISABLED)


        current_instr    = 4
        next_instruct    = 8
        pkt_id           = pkt_id_p_from_external_tcp_dport_k3

        # self.f1.i3_speculative.speculative_set_index_hash_1_w_const_val(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_PUT, mem_const_val=1)

        #for updating next instr
        self.f1.i3_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, enabled=DISABLED)

        #need recirculation
        self.pos_filter_mechansim.pos_filter_recirc_same_pipe(program_id=[program_id, MASK_PROGRAM_ID], f1_next_instr=[next_instruct, MASK_FLOW])

        ####### f1_i4 #######

        current_instr    = 7
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_external_tcp_dport_k3

        self.f1.i4_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)


        # program_id = 1
        # program_name = "PortKnocker"
        # program = Program(program_id, program_name)
        self.write_phase_mechanism.set_write_phases(program_id=program_id, write_s3=1, write_s6=1, write_s10=1)
        # program.ports=set([pFromExternal, pToExternal, pFromInternal, pToInternal])
        # self.program_id_mechanism.add_program(program)


        # self._final_configs_()
        # self.program_enabler_mechanism.enable_program()
        # self.program_id_mechanism.set_program(1)
        return self

        # ####### Write Phase Configuration #######
        # self.write_phase_mechanism.set_write_phases(write_s3=1, write_s6=1, write_s10=1)

        # self._final_configs_()
        # self.program_enabler_mechanism.enable_program()
        