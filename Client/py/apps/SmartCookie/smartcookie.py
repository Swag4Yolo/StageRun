from lib.tofino.runtime import *
from lib.tofino.types import *
from lib.tofino.constants import *
from lib.utils.utils import *
from lib.engine.engine_controller import *


class SystemApp(EngineController):

    def __init__(self, bfrt_runtime:bfrt_runtime):
        super().__init__(bfrt_runtime)
        self.program_name = "SmartCookie"

    """
    pkt_id_p_from_internet_syn_flag
        tmp, cookie = {1, 2} => only tmp can pass values from V->H and vice-versa

        In|S
        1 | f2 i1,i2   p.tcp.ack = p.tcp.seq + 1 
        2 | f1 i1,i2   tmp = syn_cookie 
                __write_s3__
        3 | f1 i3  p.tcp.seq = tmp
        5 | f2 i3  RTS pToInternet
                __write_s5__
        4 | f1 i5   p.tcp.flags = TCP_SYN_FLAG | TCP_ACK_FLAG
                __write_s10__ (flush to flags)
        
                


        6  | f1 i1,i2  tmp = tcp.ack - 1
        7  | f2 i1,i2  cookie = syn_cookie
                __write_s3__
        8  | f1 i3 if tmp == cookie:
                __write_s5__
        9  | f1 i5     Fwd pToServer
                 else:
        10 | f1 i5      DROP
    """


    # Elements that need to be gathered from the manifest, need to appear as argument of the install method; otherwise they have been generated by the compiler
    def install(self, pFromInternet, pToInternet, pFromServer, pToServer, target_hw, program_id):
        # self._init_configs_()

        
        ########################################
        #######       PORTS CONFIG       #######
        ########################################

        if (target_hw):
            pFromInternet =  self.port_mechanism.port_hdl.get_dev_port(pFromInternet, 0)
            pToInternet =  self.port_mechanism.port_hdl.get_dev_port(pToInternet, 0)
            pFromServer = self.port_mechanism.port_hdl.get_dev_port(pFromServer, 0)
            pToServer = self.port_mechanism.port_hdl.get_dev_port(pToServer, 0)

        ########################################
        ####### CONSTANTS OF THE PROGRAM #######
        ########################################

        
        ########################################
        #######     PKT IDS GENERATED    #######
        ########################################

        # Is generated one packet id per rule, so n + 2 ()
        pkt_id_disabled                 = 0
        pkt_id_all                      = 1
        pkt_id_p_from_internet_syn_flag = 2
        pkt_id_p_from_internet_ack_flag = 3
        pkt_id_p_from_server            = 4
        
        ########################################
        #######     HASH UNITS CONFIG    #######
        ########################################
        self.hash_mechanism[0].set_hash_mechanism([HASH_IPV4_SRC_ADDR, HASH_IPV4_DST_ADDR, HASH_L4_SPORT, HASH_L4_DPORT, HASH_FIELD1])

        ########################################
        #######     PREFILTER RULES      #######
        ########################################

        # Each body has a unique instruction number

        pkt_id  = pkt_id_p_from_internet_syn_flag
        ni_f1   = 2
        ni_f2   = 1
        original_port = pFromInternet

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, original_ig_port=[original_port, MASK_PORT], tcp_flags=[MASK_TCP_SYN_FLAG, MASK_TCP_SYN_FLAG], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        pkt_id  = pkt_id_p_from_internet_ack_flag
        ni_f1   = 6
        ni_f2   = 7
        original_port = pFromInternet

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, original_ig_port=[original_port, MASK_PORT], tcp_flags=[MASK_TCP_ACK_FLAG, MASK_TCP_ACK_FLAG], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        pkt_id  = pkt_id_p_from_server
        ni_f1   = INSTRUCTION_FINISH
        ni_f2   = INSTRUCTION_FINISH
        original_port = pFromServer

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id, original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)


        # ### Default Entry
        # pkt_id  = pkt_id_all
        # ni_f1   = 1
        # ni_f2   = INSTRUCTION_FINISH

        # ### set default
        # self.pre_filter_mechanism.set_default_entry(BaseAction("set_pkt_id", pkt_id, ni_f1, ni_f2))


        ########################################
        #######       GENERIC FWD        #######
        ########################################
        pkt_id  =  pkt_id_p_from_server
        port    =  pToInternet
        self.generic_fwd.fwd(program_id=program_id, pkt_id=pkt_id, port=port)

        ########################################
        #######      PROGRAM RULES       #######
        ########################################

        ####### f2_i1 #######

        current_instr    = 1
        next_instruct    = 5
        pkt_id           = pkt_id_p_from_internet_syn_flag

        self.f2.i1_p1.fetch_tcp_seq(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])

        self.f2.i1_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, const_val=1, header_id=HEADER_TCP_ACK_NO, header_update=1)

        ####### f1_i1 #######
        current_instr    = 2
        next_instruct    = 2 # could be 3 -> in that case we would use exec_instr, but by doing this we can probably skip it in the future, allowing to add more x1 instruction 
        pkt_id           = pkt_id_p_from_internet_syn_flag

        # self.f1.i1_p1.fetch_hash_1(ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID]) # not needed because, tmp doesn't need to be remembered more

        self.f1.i1_speculative.speculative_fetch_hash_1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_to_header=1)

        ### write s3 ###

        ####### f2_i1 #######
        current_instr    = 5
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_internet_syn_flag

        self.f2.i3_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, rts=1)

        ####### f1_i1 #######

        current_instr    = 2
        next_instruct    = 4
        pkt_id           = pkt_id_p_from_internet_syn_flag

        self.f1.i3_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_id=HEADER_TCP_SEQ_NO, header_update=1)
        
        const_val = MASK_TCP_ACK_FLAG | MASK_TCP_SYN_FLAG
        self.f1.i3_speculative.speculative_fetch_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, const_val=const_val, var_to_header=1)

        ### write s5 ###

        current_instr    = 4
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_internet_syn_flag

        self.f1.i5_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, header_id=HEADER_TCP_FLAGS, header_update=1)


        ### write s10 ###

        ######## 2nd Part of the program ########

        current_instr    = 6
        next_instruct    = 6
        pkt_id           = pkt_id_p_from_internet_ack_flag


        self.f1.i1_speculative.speculative_fetch_tcp_ack(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=current_instr, header_to_var=1)


        ### flow 2 ###
        current_instr    = 7
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_internet_ack_flag

        self.f2.i1_p1.fetch_hash_1(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID])

        self.f2.i1_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=2, var_update=1)


        ### write s3 ###

        current_instr    = 6
        next_instruct    = 6
        pkt_id           = pkt_id_p_from_internet_ack_flag

        self.f1.i3_p2.sum_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, const_val=-1, var_id=1, var_update=1)

        ### write s5 ###

        current_instr    = 6
        next_instruct    = 6 # should be 8
        pkt_id           = pkt_id_p_from_internet_ack_flag

        self.f1.i6_speculative.speculative_conditional_between_vars(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, cond_mode=COND_MODE_EQUALS)
        
        
        current_instr    = 6
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_from_internet_ack_flag

        self.f1.i7_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], port=pToServer, cval=[0, MASK_COND_VAL], cm=[COND_MODE_EQUALS, MASK_COND_MODE])

        self.f1.i7_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mark_to_drop=1)


        # program_id = 1
        # program_name = "SmartCookie"
        # program = Program(program_id, program_name)
        self.write_phase_mechanism.set_write_phases(program_id=program_id,write_s3=1, write_s5=1, write_s10=1)
        # program.ports=set([pFromInternet, pToInternet, pFromServer, pToServer])
        # self.program_id_mechanism.add_program(program)


        # self._final_configs_()
        # self.program_enabler_mechanism.enable_program()
        # self.program_id_mechanism.set_program(1)
        return self

        # ####### Write Phase Configuration #######
        # self.write_phase_mechanism.set_write_phases(write_s3=1, write_s5=1, write_s10=1)

        # self._final_configs_()
        # self.program_enabler_mechanism.enable_program()
        