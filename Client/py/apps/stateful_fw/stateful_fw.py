from lib.tofino.runtime import *
from lib.tofino.types import *
from lib.tofino.constants import *
from lib.utils.utils import *
from lib.engine.engine_controller import *


class SystemApp(EngineController):

    def __init__(self, bfrt_runtime:bfrt_runtime):
        super().__init__(bfrt_runtime)
        self.program_name = "Statefull Firewall"

    # Elements that need to be gathered from the manifest, need to appear as argument of the install method; otherwise they have been generated by the compiler
    def install(self, externalIn, externalOut, internalIn, internalOut, target_hw, program_id):
        # self._init_configs_()

        
        ########################################
        #######       PORTS CONFIG       #######
        ########################################

        if (target_hw):
            externalIn =  self.port_mechanism.port_hdl.get_dev_port(externalIn, 0)
            internalIn =  self.port_mechanism.port_hdl.get_dev_port(internalIn, 0)
            externalOut = self.port_mechanism.port_hdl.get_dev_port(externalOut, 0)
            internalOut = self.port_mechanism.port_hdl.get_dev_port(internalOut, 0)

        ########################################
        ####### CONSTANTS OF THE PROGRAM #######
        ########################################

        
        ########################################
        #######     PKT IDS GENERATED    #######
        ########################################

        # Is generated one packet id per rule, so n + 2 ()
        pkt_id_disabled                = 0
        pkt_id_all                     = 1
        pkt_id_p_internalIN            = 2
        pkt_id_p_externalIN            = 3
        
        ########################################
        #######     HASH UNITS CONFIG    #######
        ########################################
        self.hash_mechanism[0].set_hash_mechanism([HASH_IPV4_SRC_ADDR, HASH_IPV4_DST_ADDR, HASH_L4_SPORT, HASH_L4_DPORT])
        self.hash_mechanism[1].set_hash_mechanism([HASH_IPV4_DST_ADDR, HASH_IPV4_SRC_ADDR, HASH_L4_DPORT, HASH_L4_SPORT])

        ########################################
        #######     PREFILTER RULES      #######
        ########################################

        # Each body has a unique instruction number

        pkt_id  = pkt_id_p_internalIN
        ni_f1   = 1
        ni_f2   = INSTRUCTION_FINISH
        original_port = internalIn

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id,original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)

        pkt_id  = pkt_id_p_externalIN
        ni_f1   = 2
        ni_f2   = INSTRUCTION_FINISH
        original_port = externalIn

        self.pre_filter_mechanism.set_pkt_id(program_id=program_id,original_ig_port=[original_port, MASK_PORT], pkt_id=pkt_id, ni_f1=ni_f1, ni_f2=ni_f2)




        # ### Default Entry
        # pkt_id  = pkt_id_all
        # ni_f1   = 1
        # ni_f2   = INSTRUCTION_FINISH

        # ### set default
        # self.pre_filter_mechanism.set_default_entry(BaseAction("set_pkt_id", pkt_id, ni_f1, ni_f2))


        ########################################
        #######       GENERIC FWD        #######
        ########################################
        pkt_id  =  pkt_id_p_internalIN
        port    =  externalOut
        qid     =  0
        self.generic_fwd.fwd_and_enqueue(program_id=program_id,pkt_id=pkt_id, port=port, qid=qid)

        pkt_id  =  pkt_id_p_externalIN
        port    =  internalOut
        qid     =  0
        self.generic_fwd.fwd_and_enqueue(program_id=program_id,pkt_id=pkt_id, port=port, qid=qid)


        ####### f1_i1 #######

        current_instr    = 1
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_internalIN

        self.f1.i1_p1.set_index_hash_1_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_PUT, mem_const_val=1)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct)


        current_instr    = 2
        next_instruct    = 3
        pkt_id           = pkt_id_p_externalIN

        self.f1.i1_p1.set_index_hash_2_w_const_val(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], mode=REG_OP_MODE_GET)

        self.f1.i1_p2.reg1_new_value_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], instr_id=next_instruct, var_id=1, var_update=1)

        ### Write Phase on s3
        current_instr    = 3
        next_instruct    = INSTRUCTION_FINISH
        pkt_id           = pkt_id_p_externalIN

        self.wp_s3.conditional_mechanism_after_reg.process_conditional_after_reg_f1(program_id=program_id, ni=current_instr, pkt_id=pkt_id, cond_mode=COND_MODE_EQUALS, cond_val=0)

        self.f1.i3_p2.fwd_ni(program_id=program_id, ni=current_instr, pkt_id=[pkt_id, MASK_PKT_ID], cm=[COND_MODE_EQUALS, MASK_COND_MODE], cval=[0, MASK_COND_VAL], instr_id=INSTRUCTION_FINISH, mark_to_drop=1)



        program_name = "StatefulFirewall"
        program = Program(program_id, program_name)
        program.set_write_phases(write_s3=1, write_s10=1)
        program.ports=set([externalIn, externalOut, internalIn, internalOut])
        self.program_id_mechanism.add_program(program)


        # self._final_configs_()
        self.program_enabler_mechanism.enable_program()
        self.program_id_mechanism.set_program(program_id)
        return self